import type { NextApiRequest, NextApiResponse } from 'next'
import { createHmac } from 'crypto'
import {
	findRoom,
	createRoom,
	endRoom,
	addAttendee,
	rmAttendee,
} from 'src/bots/coworking/db'
import {
	slackPostComment,
	slackUpdateMessage,
} from 'src/bots/coworking/message'
import { getAttendee } from 'src/bots/slackUtil/redis'
import { logger } from 'util/logger'

const EVENT_MEETING_STARTED = 'meeting.started'
const EVENT_MEETING_ENDED = 'meeting.ended'
const EVENT_PARTICIPANT_JOINED = 'meeting.participant_joined'
const EVENT_PARTICIPANT_LEFT = 'meeting.participant_left'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
	const hookToken = process.env.ZOOM_WEBHOOK_AUTH as string
	const zSignature = req.headers['x-zm-signature']
	const zTimestamp = req.headers['x-zm-request-timestamp']
	const zVerify = `v0:${zTimestamp}:${JSON.stringify(req.body)}`
	const zVerifyHash = `v0=${createHmac('sha256', hookToken)
		.update(zVerify)
		.digest('hex')}`

	if (zSignature !== zVerifyHash) {
		logger.error(
			'Unauthorized',
			JSON.stringify(req.headers, null, 2),
			JSON.stringify(req.body, null, 2)
		)
		return res.status(401).json({ message: 'Unauthorized' })
	}
	const body: ZoomReqBody = req.body
	logger.info('Incoming webhook', req.body)
	if (req.body.payload.object.participant)
		logger.info('Participant', req.body.payload.object.participant)
	if (body.payload.object.id === process.env.ZOOM_COWORKING_MEETING_ID) {
		const { uuid, start_time } = body.payload.object

		switch (body.event) {
			case EVENT_PARTICIPANT_JOINED:
			case EVENT_PARTICIPANT_LEFT:
				const { user_name } = body.payload.object.participant ?? {
					user_name: undefined,
				}
				if (!user_name)
					return res.status(400).json({ message: 'No user sent!' })

				const roomInstance = await findRoom(uuid)
				if (!roomInstance)
					return res.status(404).json({ message: 'Room not found' })

				if (body.event === EVENT_PARTICIPANT_JOINED) {
					const person = await getAttendee(user_name)
					if (person) await addAttendee(person)
				} else {
					await rmAttendee(user_name)
				}

				const commentResult = await slackPostComment({
					event: body.event,
					timestamp: roomInstance.threadTimestamp,
					timestampJr: roomInstance.jrThreadTimestamp,
					username: user_name,
				})
				logger.info('Comment posted:', commentResult)
				const attendeeUpdate = await slackUpdateMessage(
					{
						timestamp: roomInstance.threadTimestamp,
						timestampJr: roomInstance.jrThreadTimestamp,
					},
					true
				)
				res.status(200).json({ commentResult, attendeeUpdate })
				return
				break
			case EVENT_MEETING_STARTED:
				const roomCreateMessage = await slackUpdateMessage()
				if (!roomCreateMessage) {
					res.status(500).end()
					return
				}
				const { inreach, inreachJr } = roomCreateMessage
				const newRoom = await createRoom(
					uuid,
					inreach.ts!,
					inreachJr.ts!,
					start_time
				)
				logger.info('Room created:', newRoom)
				res.status(200).json(newRoom)
				return
				break

			case EVENT_MEETING_ENDED:
				const roomEnd = await findRoom(uuid)

				if (!roomEnd) return res.status(400).json({ message: 'Room not found' })

				const messageEnd = await slackUpdateMessage({
					timestamp: roomEnd.threadTimestamp,
					timestampJr: roomEnd.jrThreadTimestamp,
				})
				await endRoom(uuid, body.payload.object.end_time!)
				logger.info('Room ended:', messageEnd)
				res.status(200).json(messageEnd)
				return
				break
		}
	}
	res.status(200).json({ message: 'ok' })
}

export default handler
// Generated by https://quicktype.io

export interface ZoomReqBody {
	payload: Payload
	event_ts: number
	event: string
}

interface Payload {
	account_id: string
	object: ReqObject
}

interface ReqObject {
	uuid: string
	participant?: Participant
	id: string
	type: number
	topic: string
	host_id: string
	duration: number
	start_time: string
	timezone: string
	end_time?: string
}

interface Participant {
	user_id: string
	user_name: string
	participant_user_id: string
	id: string
	join_time?: string
	email: string
	leave_time?: string
	registrant_id?: string
	leave_reason?: string
}
